<!-- Кузнецов Богдан Романович
https://www.coursera.org/learn/snovy-html-i-css/peer/6mMfX/razmietit-tiekst/review-next
https://s3.amazonaws.com/coursera-uploads/peer-review/e410a028d2438ae5d373252517ae7cbc/___-__.html -->

<!DOCTYPE html>
<html>
<head>
	<html lang="rus">
	<meta charset="utf-8">
	
	<title>Блог компании Яндекс.</title>
</head>
<body>
	<h1>ЯНДЕКС.ПОЧТА: КАК МЫ ИЗМЕРЯЕМ СКОРОСТЬ ЗАГРУЗКИ И УЛУЧШАЕМ ЕЁ</h1>
	<p>Если ваш сайт медленно грузится, вы рискуете тем, что люди не оценят ни то,<br>
какой он красивый, ни то, какой он удобный. Никому не понравится, когда все<br>
тормозит. Мы регулярно добавляем в Яндекс.Почту новую функциональность,<br>
иногда — исправляем ошибки, а это значит, у нас постоянно появляются новый код<br>
и новая логика. Всё это напрямую влияет на скорость работы интерфейса.<br>
</p>
<h2>Что мы измеряем</h2>
<ul>Этапы первой загрузки:
<li>подготовка;</li>
<li>загрузка статики (<abbr>HTTP</abbr><title>Hyper Text Transfer Protocol</title>-запрос и парсинг);</li>    
<li>исполнение модулей;</li>
<li>инициализация базовых объектов;</li>
<li>отрисовка.</li>
      </ul>
<ul>Этапы отрисовки любой страницы:
<li>подготовка к запросу на сервер;</li>
<li>запрос данных с сервера;</li>
<li>шаблонизация;</li>
<li>обновление <abrr>DOM</abrr>.</li>
</ul>
<q>Ок, теперь у нас есть метрики, мы можем отправить их на сервер</q></body><cite>- говорим мы</cite><br>
<q>Что же дальше?</q> <cite>- вопрошаете вы</cite><br>
<q>А давай построим график</q> <cite>- отвечаем мы</cite><br>
<q>А что будем считать</q>  <cite>- уточняете вы</cite><br>
<p>Как вы знаете, медиана – это серединное, а не среднее значение в выборке.<br>
Если у нас имеются числа 1, 2, 2, 3, 8, 10, 20, то медиана – 3, а среднее – 6,5.<br>
В общем случае медиана отлично показывает, сколько грузится средний пользователь.<br></p>
<p>В случае ускорения или замедления медиана, конечно, изменится. Но она не может<br>
рассказать, сколько пользователей ускорилось, а сколько замедлилось<br></p>
<p> APDEX – метрика, которая сразу говорит: хорошо или плохо. Метрика<br>
работает очень просто. Мы выбираем временной интервал [0; t], такой, что если<br>
время показа страницы попало в него, то пользователь счастлив. Берем еще один<br>
интервал, (t; 4t] (в четыре раза больше первого), и считаем, что если страница<br>
показана за это время, то пользователь в целом удовлетворен скоростью работы,<br>
но уже не настолько счастлив. И применяем формулу:<br>
<p>(кол-во счастливых пользователей + кол-во удовлетворенных / 2) / (кол-во всех).<br>
Получается значение от нуля до единицы, которое, видимо, лучше всего показывает,<br>
хорошо или плохо работает почта.<br></p>
<h2>Как мы измеряем</h2>
<p>Сейчас модуль обновления сам логирует все свои стадии, и можно легко понят<br>
причину замедления: медленнее стал отвечать сервер либо слишком долг<br>
выполняется JavaScript. Выглядит это примерно так:<br></p>
<code>this.timings['look-ma-im-start'] = Date.now();<br>
this.timings['look-ma-finish'] = Date.now();<br></code>
<p>C помощью Date.now() мы получаем текущее время. Все тайминги собираются и при<br>
отправке рассчитываются. На этапах разница между “end” и “start” не считается,<br>
а все вычисления производятся в конце:<br></p>
<code>var totalTime = this.timings['look-ma-finish'] - this.timings['look-ma-im-start'];<br></code>
<p>И на сервер прилетают подобные записи:</p>
<code>serverResponse=50&domUpdate=60</code>
<h2>Как мы ускоряем</h2>
<p>
	Чтобы снизить время загрузки почты при выходе новых версий,<br>
мы уже делаем следующее:
</p>
<ul>
<li>включаем gzip; </li>	
<li>выставляем заголовки кэширования;</li>	
<li>фризим CSS, <abrr>JS</abrr>, шаблоны и картинки;</li>
<li>используем <abrr>CDN;</abrr></li>
</ul>
<p>Мы подумали:<q>А что если хранить где-то старую версию файлов, а при выходе новой<br>
передавать только diff между ней и той, которая сохранена у пользователя?</q><br>
В браузере же останется просто наложить патч на клиенте.<br></p>
<p>На самое деле эта идея не нова. Уже существуют стандарты для HTTP — например,<br>
RFC 3229 «Delta encoding in HTTP» и «Google SDHC», — но по разным причинам они<br>
не получили должного распространения в браузерах и на серверах.<br></p>
<p>ы же решили сделать свой аналог на JS. Чтобы реализовать этот метод обновления,<br>
начали искать реализации diff на JS. На популярных хостингах кода нашли<br>
библиотеки:<br>
- VCDiff<br>
- google-diff-patch-match<br>
</p>
<h3>Для окончательного выбора библиотеки нам нужно сравнить:</h3>
<table border="1" width="20%">
	<thead>
	<tr align="center">
		<th>Библиотека</th>
		<th>IE9</th>
		<th>Opera12</th>
	</tr>
</thead>
<tr align="center">
	<td>vcdiff</td>
	<td>8</td>
	
<td>5</td>

</tr>
<tr align="center">
	<td>google diff</td>
	<td>1363</td>
	<td>76</td>

</tr>

</table>
<p>После того как мы определились с библиотекой для диффа, нужно определиться с тем,<br>
где и как хранить статику на клиенте.</p>
<h3>Формат файла с патчами для проекта выглядит так:</h3>
<code>
	
	[
    {
        "k": "jane.css",<br>
        "p": [patch],<br>
        "s": 4554<br>
    },
    {
        "k": "jane.css",<br>
        "p": [patch],<br>
        "s": 4554<br>
    }
]

</code>
<p> То есть это обычный массив из объектов. Каждый объект — отдельный ресурс. У<br>
каждого объекта есть три свойства. k — названия ключа в localStorage для этого<br>
ресурса. p — патч для ресурса, который сгенерировал vcdiff. s — чексумма для<br>
ресурса актуальной версии, чтобы потом можно было проверить правильность<br>
наложения патча на клиенте. Чексумма вычисляется по алгоритму Флетчера.<br>
</p>
<dl><dt>Алгоритм Бройдена — Флетчера — Гольдфарба — Шанно (BFGS)</dt><dd><br>
— итерационный метод численной оптимизации, предназначенный для<br>
нахождения локального максимума/минимума нелинейного функционала<br>
без ограничений.</dd></dl>
<p>Почему именно алгоритм Флетчера, а не другие популярные алгоритмы вроде:<br>
CRC16/32 - алгоритм нахождения контрольной суммы, предназначенный для проверки<br>
целостности данных<br>
md5 - 128-битный алгоритм хеширования. Предназначен для создания «отпечатков»<br>
или дайджестов сообщения произвольной длины и последующей проверки<br>
их подлинности.<br></p>
<h2>Потому что он быстрый, компактный и легок в реализации.
</h2>
<h1><strong>Итог</strong></h1>
<h3>Фактически мы экономим 80-90% трафика. Размер загружаемой статитки в байтах:</h3>
<table border="1" width="20%">
	<tr align="center">
	<th>Релиз</th>
	<td>С патчем</td>
	<td>Без патча</td>	


	</tr>
	<tr align="center">
		<td>7.7.20</td>
		<td>397</td>
		<td>174 549</td>


	</tr>
	<tr align="center">
		<td>7.7.21</td>
		<td>383</td>
		<td>53 995</td>
	</tr>
<tr align="center">
	<td>7.7.22</td>
	<td>483</td>
	<td>3 995</td>
</tr>
</table>



<header>Автор: <a href="@doochik">(@doochik)</a><br>
С++ разработик<br>
Электронная почта:<a href="doochik@yandex-team.ru">(doochik@yandex-team.ru)</a><br>
Компания: <a href="http://yandex.ru">Яндекс</a><br></header>

</p>
<article>
	<section>
	<h2>Коментарии (3):</h2>
<article>
	-Mogaika <a href="mogaika@yandex-team.ru">(mogaika@yandex-team.ru)</a> <time datetime="2014-11-30T17:00">30 ноября 2014 в 17:05</time>
	<p><q>А можете привести сравнение, на сколько быстрее грузится lite версия?</q>
</p>


 <article>
	-JIguse <a href="mrawesome@yandex.ru">(mrawesome@yandex.ru)</a> <time datetime="2014-11-29T21:30">29 ноября 2014 в 21:30
	<p><q>Спасибо за статью, познавательно. Здорово, что Яндекс делится некоторыми
  подробностями о внутренней работе сервисов.</q></p>

</article>
<article>
	- Brister <a href="brist89@yandex-team.ru ">(brist89@yandex-team.ru) </a> <time datetime="2014-11-24T13:13">24 ноября 2014 в 13:13
	<p><q>(кол-во счастливых пользователей + кол-во удовлетворенных / 2) / (кол-во всех).
  Получается значение от нуля до единицы, которое, видимо, лучше всего показывает,
  хорошо или плохо работает почта.<br>
  наверное все-таки от 0.5 до 1<q/></p><br>


</article>
<article>
	- alexeimois <a href="test@yandex.ru">(test@yandex.ru)</a><time datetime="2014-11-22T17:35"> 22 ноября 2014 в 17:35
	<p> Мы измеряем скорость загрузки с помощью Яндекс.Метрики:
  <a href="help.yandex.ru/metrika/reports/monitoring_timing.xml"
 title="Yandex">help.yandex.ru/metrika/reports/monitoring_timing.xml</a></p>

</article>

</article> 

</body>
<hr>
<footer>© Яндекс, <a href="help@yandex.ru">help@yandex.ru</a>, Хохрякова, 10</footer>
</html>